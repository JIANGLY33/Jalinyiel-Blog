# 详解红黑树

### 1.红黑树简介

普通的BST(binary search tree)在极端情况下可能会发生倾斜，导致其退化成类似线性表的结构，从而使得查找效率大大降低，而红黑树等平衡二叉搜索树的出现就是为了解决这个问题。相比BST，红黑树在每次插入或者删除后都会进行自平衡操作，旨在为了保证整棵树不会发生过度的倾斜，从而能够保证查找的效率能够维持在一个较高的水平。得益于它的良好效率，红黑树的应用十分广泛，如Java集合框架中的TreeMap，TreeSet，以及JDK1.8以后的HashMap也用红黑树改良了性能。

### 2.红黑树的性质

为了维护整棵树的平衡，红黑树主要有以下四点性质：

```html
1.每个节点要么是红色要么黑色
2.根节点是黑色的
3.红色节点的子节点不能是红色
4.从根节点到叶子节点的每条路径上的黑色节点数量是相同的
```

得益于以上性质，我们可以发现：**红黑树的最长路径在极限情况下只能是最短路径的两倍**。这种情况发生时：最短路径上的所有节点都为黑色，最长路径上的节点始终是黑红交替排列的。如下图所示：

<img src="https://raw.githubusercontent.com/JIANGLY33/Jalinyiel-Blog/master/Images/length.png"  height =" 430" width = "372" />

性质1和性质2主要的作用是给出红黑树的定义，而性质3和性质4则是红黑树高效的秘诀。但任何事物都有其正反两面，性质3和性质4在带来高效率的同时，也使得红黑树的一些操作，如插入，删除操作，在实现的难度上要远高于普通的BST。因为插入，删除操作带来的节点增加与删除很有可能使性质3或性质4被破坏，因此我们往往需要在插入或者删除后对红黑树进行修复，使其重新遵守这两条性质。

### 3.左旋与右旋

在红黑树的自平衡操作中，我们**优先采取将节点变色的方式让被破坏的红黑树恢复性质**，因为变色的方式相对比较简单，然而当变色操作无力回天时，我们需要采取进一步的操作来拯救被破坏的红黑树，而这进一步的操作就是接下来要介绍的左旋与右旋。

左旋操作图示如下：

![左旋示意图](<https://raw.githubusercontent.com/JIANGLY33/Jalinyiel-Blog/master/Images/zag1.png>)

可以看到将P节点左旋后将发生以下变化：P的右儿子A2来到P的位置，而P成为了A2的左儿子，这样A2原先的左儿子D1就需要寻找新的位置，恰好P失去了它的右儿子，而D1的值必然大于P的值，故D1成为了P的右儿子，除此之外P的左子树，A2的右子树都将不受影响。总结一下：将节点P左旋只改变了节点P和它的右子节点A2和A2的左子节点D1的位置，具体的改变方式是让**A2来到P的位置，P成为A2的左子节点，而D1成为P的右子节点。**



右旋操作示意图则如下：

![右旋示意图](<https://raw.githubusercontent.com/JIANGLY33/Jalinyiel-Blog/master/Images/zig1.png>)

节点P右旋后，它的左子节点A1将来到它的位置，而P将成为A1的右儿子，这样A1原先的右儿子D1就失去了位置，恰逢P失去了它的左儿子，而D1的值必然小于P的值，因此D1也就顺理成章地成为了P的新任左儿子。除这三个节点之外，A1的左子树和P的右子树均不受旋转操作的影响。简要总结一下：将节点P右旋只改变了节点P和它的左子节点A1和A1的右子节点D1的位置，具体的改变方式是让**A1来到P的位置，P成为A1的右子节点，而D1成为P的左子节点。**



### 4.红黑树的基本操作

#### 4.1 查找操作

红黑树的查找操作与普通的二叉搜索树并无二致，以下直接给出代码，便不再赘述其原理。

```java
public T find(T value) {
        RBTreeNode<T> dataNode = getRoot();
        while(dataNode != null) {
            int cmp = dataNode.getValue().compareTo(value);
            if(cmp < 0) {
                dataNode = dataNode.getLeft();
            }else if(cmp > 0) {
                dataNode = dataNode.getRight();
            }
            else {
                return dataNode.getValue();
            }
        }
        return null;
	}
```



#### 4.2 插入操作

红黑树的插入操作与普通的BST插入操作基本一致，但在插入新节点后可能会破坏红黑树的性质，故需要在执行插入操作之后检查红黑树性质是否被破坏，如果被破坏的话，还需要执行插入修复操作。

需要事先说明的是：为了简化插入操作，我们一般**将新插入的节点设为红色**，因为如果插入黑色节点的话必将破坏性质4，正如我们将在删除操作中看到的，该性质一旦被破坏，修复起来可能会十分麻烦，而将新插入节点默认设为红色节点的话，我们一定不会破坏这条性质，虽然<u>有可能</u>破坏性质3，但修复该性质也相对更加容易。

接下来我们开始讨论具体的插入操作：得益于将新插入的节点设为红色，我们便无需再担心性质4遭到破坏，而我们知道二叉搜索树新插入的节点必然将成为叶子节点，因此在考虑违反性质3的颜色冲突时，<u>只需要关注新插入节点父节点的颜色即可。</u>倘若父节点为黑色，那么性质3将不会被破坏，我们也无需进行修复，此时红黑树的插入操作与普通BST完全一致，而倘若父节点为红色，那么性质3将遭到破坏，此时我们就需要考虑修复操作。

我们将具体的破坏情况分为以下：

```html
1.叔叔节点不存在且插入节点和父节点、祖父节点在同一条斜线上
2.叔叔节点不存在且插入节点和父节点、祖父节点不在同一条斜线上
3.叔叔节点为红色节点
```

值得一提的是：叔叔节点不可能是黑色节点，因为在插入节点是叶子节点且其父节点为红的前提下，叔叔节点若为黑色，则这颗红黑树原本就违背了性质4，因此不可能存在这种情况。但在红黑树自平衡过程中可能会出现叔叔节点为黑色的情况，这时我们将叔叔节点视为不存在进行处理即可。

我们先从第一种情况开始讨论，插入节点N后的情况如下图左部所示。正如先前在第三小节中提到的那样，我们优先考虑采用变色的手段进行修复，但显然单纯的变色无法应对这种情况，如果我们将N节点或其父节点P中的任意一个变为黑色，性质3的确被修复了，但从整体上看，性质4将被破坏，因为新增了一个黑色节点，而我们前文中曾谈到，性质4被破坏的情况将比性质3被破坏的情况更加严峻，因此这种做法是舍本逐末并不可取的。

既然变色无法完成修复，我们不得不采用旋转的方法，幸运的是：**将祖父节点G右旋后再将其染成红色，随后再将节点P染成黑色**，性质3便成功被修复了，最终的情况如下图右部所示。

![insertion1](<https://raw.githubusercontent.com/JIANGLY33/Jalinyiel-Blog/master/Images/insert11.png>)

第二种情况下插入节点N后如下图左部所示，这种情况同上一种情况一样，无法单纯地由变色来修复性质，我们采取的做法是**将父节点P左旋**，从而得到下图右部所示的情况，而这种情况正是先前的情况一！因此我们**只需再按照情况一的做法进行修复便可完成最终的修复**。

![insertion2](<https://raw.githubusercontent.com/JIANGLY33/Jalinyiel-Blog/master/Images/insert21.png>)

第三种情况插入节点N后如下图左部所示，这种情况下只需执行变色操作就可以使局部重新遵从性质3，具体的做法是**将祖父节点染红，并把它的两个儿子节点染黑**。但我们要注意到，祖父节点G的父节点可能也是红色的，而我们将祖父节点染红就意味着祖父节点可能会和它的父节点发生颜色冲突，在这种情况下我们需要再次进行插入修复(将祖父G视作新插入的节点)。在最坏的情况下我们可能需要一直回溯到根节点来进行插入修复，但幸运的是最终插入修复是肯定可以完成的。

![insertion3](<https://raw.githubusercontent.com/JIANGLY33/Jalinyiel-Blog/master/Images/insert31.png>)



#### 4.3 删除操作

红黑树的删除操作同样建立在普通BST删除操作的基础上，但在删除节点后很有可能破坏红黑树的性质3或者性质4，因此也需要检查性质是否被破坏，进而考虑是否需要进行修复操作。

首先我们讨论被删除节点的颜色问题，显然**如果被删除节点是红色的，那么红黑树的性质将不会被破坏**，此时红黑树的删除操作与普通BST的删除操作并无二致，而倘若被删除节点是黑色，那么该节点所在的到根节点的路径上少了一个黑色节点，性质4必然被破坏，而且性质3也有可能被破坏，因此**如果被删除节点是黑色，则需要进行删除修复操作。**

接下来我们讨论删除节点可能出现的位置关系，虽然被删除节点可能是红黑树中任意一个节点，但该节点被删除后，如果它的右子树存在，那么它的右子树中左下角的节点（即中序遍历红黑树时被删除节点的下一个节点）将对它进行“补位”，补位后原先被删除节点处将不会出现违反红黑树性质的情形，而前去补位的节点原先所在的位置将出现空缺，并且补位节点必然没有左儿子，故我们就<u>可以把删除红黑树中任意位置节点的情况转换为删除没有左儿子的节点的情形。</u>然而以上讨论的这种删除节点的位置转换是在原先被删除节点存在右子树的前提下，倘若原先被删除节点不存在右子树，那么为了遵守性质3和性质4，它要么没有左儿子（意味着被删除节点是叶子节点），要么有红色的左儿子，且它的左儿子必然没有儿子节点。

综上所述，<u>实际上被删除的节点的位置情况只有三种可能，一是它位于倒数第二层且只有红色左儿子，二是被删除节点没有左儿子，三是被删除节点是叶子节点。</u>而综合三种情况来看，被删除节点的左儿子节点要么不存在要么为红色，这也便利了我们后续的分析。

明确了以上关系后我们就可以开始讨论需要被修复的删除操作所涉及的具体情况，主要有以下四种：

```html
1.被删除节点的兄弟节点是红色的，则它必然有两个黑色的儿子节点

2.被删除节点的兄弟节点是黑色的，则它必然不存在儿子节点

3.被删除节点是左子树时，它的兄弟节点是黑色的，且其兄弟节点的右儿子是红色的，左儿子不存在或也为红色；
  被删除节点是右子树时，它的兄弟节点是黑色的，且其兄弟节点的左儿子是红色的，右儿子不存在或也为红色。

4.被删除节点是左子树时，它的兄弟节点是黑色的，且其兄弟节点的左儿子是红色的，右儿子不存在；
  被删除节点是右子树时，它的兄弟节点是黑色的，且其兄弟节点的右儿子是红色的，左儿子不存在。
```

第一种情况如下图左部所示，方框框住的节点表示被删除节点。**这种情况可以通过将被删除节点D的父节点左旋，并将兄弟节点B设为黑色，兄弟节点B的左儿子设为红色，从而完成修复**。修复后的情形如下图右部所示。

![delete2](<https://raw.githubusercontent.com/JIANGLY33/Jalinyiel-Blog/master/Images/delete21.png>)

第二种情形未修复前如下图左部所示，**这种情况只需将兄弟节点B的颜色染红即可完成<u>局部修复</u>。**但这种做法会导致更高层次的路径上少了一个黑色节点，从而性质4无法得到满足，故**需要从父节点P继续往更高层节点进行回溯删除修复**。值得一提的是，P也可能是红色的（虽然下图中不是），此时只需在将B染红的基础上再将P染黑即可完成整棵树的修复，甚至无需回溯。

![delete1](<https://raw.githubusercontent.com/JIANGLY33/Jalinyiel-Blog/master/Images/delete11.png>)

第三种情形如下图左部所示，此时的修复方法是**将被删除节点D的父节点P左旋，并将P节点和它的右儿子B节点交换颜色，再将B的右儿子染黑**。下图展示的是P节点为黑的情形，但P节点也完全可能是红色的，此时将P和B交换颜色后，下图右部的B节点就成为了红色，但我们无需担心B与它的新父节点发生颜色冲突，因为P节点原先为红就保证了这种冲突不会发生。

![delete3](<https://raw.githubusercontent.com/JIANGLY33/Jalinyiel-Blog/master/Images/delete31.png>)

最后一种情形未修复前如下图左部所示，针对这种情况我们需要**将被删除节点的兄弟节点B右旋，再把B节点染为红色，B的左儿子染为黑色，即可来到第三种情况，接下来再按照情况三的方法进行修复即可**。这里P节点也有可能是红色的，但不影响我们的修复操作。

![delete4](<https://raw.githubusercontent.com/JIANGLY33/Jalinyiel-Blog/master/Images/delete41.png>)

简要总结一下，除了第二种情况可能影响更高层节点的性质外，其他几种情形的修复操作都可以完成整棵树的平衡修复。而如果我们面临着情况二的局面，并且破坏了更高层节点要遵守的性质，那就不得不回溯到更高层节点再次进行删除修复操作。可以看到，以上的操作基本都是在对被删除节点的兄弟子树做文章，因为代价最小的修复方式就是从兄弟子树处借得节点来填补被删除节点的空缺，如果实在无法填补我们也要保证红黑树的性质在局部得到满足，继而将在局部无法完成的修复任务转交给更高层节点进行修复。

至此红黑树的分析就告一段落了，完整的红黑树代码实现请点击右侧的飞机传送😏 [ ✈✈✈](<https://github.com/JIANGLY33/CodingInterviewGuideProblemSet/tree/master/src/main/java/Datastructure>)

### 5.参考资料

1. [红黑树分析，看了都说好](<https://segmentfault.com/a/1190000012728513?utm_source=tag-newest>)

   (分析全面且完整但给出的图似乎存在问题，容易影响理解)

2. [红黑树深入剖析及Java实现](<https://zhuanlan.zhihu.com/p/24367771>)

   (思路简洁清晰，启发性强，但是似乎遗漏了一些情况，并且给出的代码存在问题)

3. [数据结构:红黑树的删除](<https://zhuanlan.zhihu.com/p/22800206>)

   (思路清晰并且图画的很直观，但也遗漏了一种情况)

