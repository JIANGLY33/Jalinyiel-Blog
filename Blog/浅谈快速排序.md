<h1> 浅谈快速排序 </h1>   

* [1. 快速排序简介](#1)

* [2. 选择pivot的策略](#2)
    * [2.1 将数组首元素选为pivot](#2.1)

    * [2.2 取随机数来作为pivot](#2.2)

    * [2.3 取三个数的中位数作为pivot](#2.3)

* [3. 划分剩余元素的策略](#3)
     * [3.1 策略简述 ](#3.1)

     * [3.2 重谈median3 ](#3.2)

     * [3.3 为什么是“大于”和“小于”？](#3.3)

* [4. 当元素个数较少时](#4)

---

<h2 id = "1"> 快速排序简介 </h2>

快速排序(Quicksort)是目前已知的运行最快的一种排序方法，**其平均时间复杂度为 _O(NlogN)_** 。该排序算法高效但是不易写，在编写算法时犯下任何一点小小的错误都可能使算法的效率大打折扣。

快速排序采用了“**分而治之**”(_divide-and-conquer_)的策略，并使用**递归**来实现。接下来首先给出快速排序算法的基本框架：
```
假设待排序数组为S，则 
       1.若S的元素个数为0或1，直接返回
       2.从S中选择一个元素v作为pivot
       3.将S除v外的剩余元素分为两部分：S1和S2。使得S1中的元素均小于v，而S2中的元素均大于v
       4.对S1和S2再分别执行快速排序 
```
整个算法最关键的是第2步和第3步，同时这两步也是存在选择空间的，算法实现者可以按照自己的方式来实现这两步，只要最终的结果满足框架的要求即可。而快速排序的效率很大程度受这两部分实现方式的影响，不同实现方式最终所得到的快排在性能上可能存在极大差别。

接下来要讨论的是几种常见的实现第二步和第三步的方法。

---

<h2 id = "2"> 选择pivot的策略 </h2>

首先从如何选择 _pivot_ 开始，下面将讨论**3种常见的选择 _pivot_ 的方法**。

---

<h3 id = "2.1">将数组首元素选为pivot</h3>

既然没有规定从数组中选择 _pivot_ 的方式，那我们可能会首先联想到**将数组的第一个元素S[0]选为 _pivot_**  。

这种方法在待排数组的元素是乱序的情况下是可以接受的，但如果待排数组是**逆序或者已经排好序**的，那么这种方法将会暴露出极大的弊端：将S[0]选为pivot后，接下来的元素将全部小于或大于S[0]，那么在执行第三步的时候将不会得到两部分S1和S2，而是会将剩下的所有元素都划为一部分，再对该部分做同样的操作。

由此可得到递推式：_T(N) = T(N-1) + O(N) = O(N²)_，而这也意味着：对于原先已经排好序的数组，我们**花费了O(N²)的时间却没有执行任何有效的操作**！因此选择数组首个元素作为 _pivot_ 是一种十分不可取的方案!

---

<h3 id = "2.2"> 取随机数来作为pivot </h3>

每次从待排数组种随机选择一个元素作为pivot似乎是行之有效的方法，它能在很大程度上避免之前所探讨的情况的出现，但是我们也必须考虑到：**random()函数本身也是需要消耗时间的**。我们在每次递归地执行快速排序时都要调用random()来选择 _pivot_ ，这将会是极大的消耗。

---

<h3 id = "2.3" > 取三个数的中位数作为pivot </h3>

首先我们来讨论一种**最为理想的方式**：即选择数组S中所有元素的中位数作为 _pivot_ ，显然这样的 _pivot_ 将使得S1和S2元素个数最为接近，从而达到最高效的分治效果。但我们必须意识到：计算S中所有元素的中位数是一件成本高昂的事情，因此**我们可以退而求其次：选择数组中三个元素并计算这三个元素的中位数**。也许这种方法并不能使后续的分治操作达到最佳效果，但是**这种计算 _pivot_ 的方法成本低廉，且能帮我们化解方法一所面对的窘境，因此不失为一种不错的方法**。

为了方便，从数组中取三个元素时，我们常常选择数组的第一个元素，最后一个元素，以及中间的元素。

接下来给出取三个数的中位数作为 _pivot_ 的具体代码：
```c
void swap(int* x, int* y) {
	int temp;
	temp = *x;
	*x = *y;
	*y = temp;
}

int median3(int array[], int left, int right) {
	int temp;
	int medium = (left + right)/2;
	if(array[left] > array[medium]) {
		swap(&array[left], &array[medium]);
	}
	if(array[left] > array[right]) {
		swap(&array[left], &array[right]);
	}
	if(array[medium] > array[right]) {
		swap(&array[medium], &array[right]);
	}
	swap(&array[medium], &array[right-1]);
	return array[right-1];
}
```
---

<h2 id = "3"> 划分剩余元素的策略 </h2>

---

<h3 id = "3.1" > 策略简述 </h3>

最常用的划分剩余元素的策略是：

设立一个头指针 _i_ 和一个尾指针 _j_  。前者从数组的首元素开始往尾部移动，一旦遇到大于 _pivot_ 的元素便暂停，此时 _j_ 开始往前移动，一旦遇到小于 _pivot_ 的元素就暂停，且如果 _i_ 仍在 _j_ 的左侧，则将两者所指的元素进行交换。而如果 _i_ 已经大于 _j_ ，则将 _i_ 所指的元素与 _pivot_ 进行交换。至此，将剩余元素划分为两部分的任务就完成了，此时 **_pivot_ 左侧的元素均小于它，而它右侧的元素均大于它**。在后续的操作中，我们只需要对 _pivot_ 左右两侧的元素再执行递归即可。

显而易见的是：**每一次的递归操作都将确定一个元素的最终位置。**

---

<h3 id = "3.2"> 重谈median3 </h3>

在之前我们的median3函数中，特意在返回 _pivot_ 前将其与最后一个元素进行换位，这也就**保证了 _i_ 在移动时的安全性（不会越界）**，此外，数组的S[0]也必然小于 _pivot_ ，因此**它可以作为一个 _sentinel_ 来保障 _j_ 在前移时同样不会越界**。

---

<h3 id = "3.3"> 为什么是“大于”和“小于”？</h3>

仔细留意可以发现我们之前在将 _i_ 和 _j_ 所指向的元素与 _pivot_ 进行比较时，是当它们“大于”和“小于” _pivot_ 时才暂停移动。那为什么不是“大于等于”和“小于等于"呢？

**这是考虑到待排数组可能存在大量重复元素而采取的优化方案**。

以一种极端的方式来考虑该问题：
```
假设待排数组中的所有元素都是完全相同的。
选择“大于”和“小于”时：
       i和j在移动过程中将不断地交换元素，虽然这种交换是毫无意义的，因为所有元素都是相同的。
       最终i和j将在数组中间位置相遇，从而使得与i换位后的pivot最终位于数组的中间位置。
       这将使得pivot左侧的元素数和右侧的元素数最为接近，在后续的分治递归时也将体现最好的效果
       即最终时间复杂度为O(NlogN)
选择“大于等于”和“小于等于”时：
       i将不暂停，直到移至最后一个元素（或倒数第二个元素，这将取决于具体的实现）。
       这也就意味着接下来要进行递归的所有元素都位于pivot的一侧，从而满足了递推式
                                T(N) = T(N-1) + O(N)
       最终的结果是：算法的时间复杂度为O(N²)
```
因此，选择“大于”和“小于”是一种相对明智的选择。

---

<h2 id = "4"> 当元素个数较少时 </h2>

---

在实践中，**当待排数组元素个数在20个以下时，快速排序的性能似乎不如插入排序**。这也并不奇怪，因为我们此前所作的分析都是基于数组元素个数极大的情况。因此，**在数组元素个数较少时，我们更应该选择插入排序** 。抛开性能问题不谈，**我们的median3函数就要求数组元素个数至少为3，因此我们在设计快速排序算法时必须考虑到数组元素个数更少时的情况**。

---

最后给出剩余部分的代码：
```c
void InsertionSort(int array[], int length) {
	int i,j,temp;
	for(i = 1; i < length; i++) {
		temp = array[i];
		for(j = i-1; (j >= 0)&&(array[j+1]<array[j]) ; j--) {
				array[j+1] = array[j];
				array[j] = temp;
		}
	}
}

void Qsort(int array[], int left, int right) {
	int i,j;
	int pivot;
	if(left + 3 < right) {
		pivot = median3(array, left, right);
		i = left, j = right-1;
		while(true) {
			while(array[++i] < pivot);
			while(array[--j] > pivot);
			if(i < j)
				swap(&array[i], &array[j]);
			else
				break; 
		} 
		swap(&array[i],&array[right-1]);
		Qsort(array,0,i-1);
		Qsort(array,i+1,right);
	}
	else
		InsertionSort(array+left,right - left + 1);
}

/* 排序算法标准接口 */ 
void QuickSort(int array[], int length) {
	Qsort(array, 0, length-1);
} 
```
